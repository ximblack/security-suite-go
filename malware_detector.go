package main

import (
	"bufio"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/hillu/go-yara/v4"
)

// MaxRecentIndicators defines the maximum number of recent indicators to store
const MaxRecentIndicators = 100

// YARA initialization rule
const YARA_INIT_RULE = `
rule InitializationRule_Core
{
  meta:
    description = "A basic rule required for YARA compiler initialization."
    author = "Security Suite Core"
    version = "1.0"
  strings:
    $init_string = "SECURITY-SUITE-YARA-INIT" wide ascii
  condition:
    filesize < 1MB and $init_string
}
`

// MalwareDetector performs multi-engine malware detection
type MalwareDetector struct {
	mu                sync.Mutex
	yaraRulesCompiled *yara.Rules
	regexPatterns     []ThreatPattern
	clamavAvailable   bool
	clamavSocket      string
	recentIndicators  []ThreatIndicator
	virusTotalAPIKey  string
	threatIntelCache  map[string]*ThreatIntelResult
	cacheMu           sync.RWMutex
}

// ThreatIntelResult caches threat intelligence lookups
type ThreatIntelResult struct {
	Hash       string
	Malicious  bool
	Detections int
	LastCheck  time.Time
	Vendors    []string
}

// NewMalwareDetector initializes the detector with all engines
func NewMalwareDetector(yaraRulesPath string, regexPatterns []ThreatPattern) (*MalwareDetector, error) {
	md := &MalwareDetector{
		regexPatterns:    regexPatterns,
		recentIndicators: make([]ThreatIndicator, 0, MaxRecentIndicators),
		clamavSocket:     "/run/clamav/clamd.ctl",
		threatIntelCache: make(map[string]*ThreatIntelResult),
	}

	// Initialize ClamAV connection
	md.initClamAV()

	// Load VirusTotal API key from environment
	md.virusTotalAPIKey = os.Getenv("VIRUSTOTAL_API_KEY")
	if md.virusTotalAPIKey != "" {
		fmt.Println("[MalwareDetector] VirusTotal API key loaded")
	}

	// Load and compile YARA rules
	if err := md.LoadYARARules(yaraRulesPath); err != nil {
		fmt.Fprintf(os.Stderr, "[MalwareDetector ERROR] Failed to load YARA rules: %v\n", err)
	}

	return md, nil
}

// initClamAV checks for ClamAV daemon availability
func (md *MalwareDetector) initClamAV() {
	if _, err := os.Stat(md.clamavSocket); err == nil {
		// Test connection
		conn, err := net.Dial("unix", md.clamavSocket)
		if err == nil {
			conn.Close()
			md.clamavAvailable = true
			fmt.Println("[MalwareDetector] ClamAV daemon connected successfully")
		} else {
			fmt.Printf("[MalwareDetector] ClamAV socket exists but connection failed: %v\n", err)
		}
	} else {
		fmt.Println("[MalwareDetector] ClamAV socket not found at", md.clamavSocket)
	}
}

// LoadYARARules compiles YARA rules from file
func (md *MalwareDetector) LoadYARARules(path string) error {
	compiler, err := yara.NewCompiler()
	if err != nil {
		return fmt.Errorf("failed to create YARA compiler: %v", err)
	}

	file, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Printf("[MalwareDetector] YARA rule file not found at %s. Using internal init rule.\n", path)
			if err := compiler.AddString(YARA_INIT_RULE, "fallback"); err != nil {
				return fmt.Errorf("failed to compile fallback YARA rule: %v", err)
			}
		} else {
			return fmt.Errorf("failed to open YARA rules file %s: %v", path, err)
		}
	} else {
		defer file.Close()
		if err := compiler.AddFile(file, "main_rules"); err != nil {
			return fmt.Errorf("failed to add YARA file %s: %v", path, err)
		}
	}

	rules, err := compiler.GetRules()
	if err != nil {
		return fmt.Errorf("failed to compile YARA rules: %v", err)
	}

	md.yaraRulesCompiled = rules
	fmt.Printf("[MalwareDetector] YARA rules loaded successfully. Total rules: %d\n", len(rules.GetRules()))
	return nil
}

// CalculateSHA256 returns the SHA256 hash of a file
func CalculateSHA256(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

// ScanFile performs multi-engine scanning on a file
func (md *MalwareDetector) ScanFile(filePath string) ([]ThreatIndicator, bool) {
	fmt.Printf("[MalwareDetector] Starting multi-engine scan on: %s\n", filePath)
	indicators := make([]ThreatIndicator, 0)
	foundThreat := false

	// 1. Calculate hash
	fileHash, err := CalculateSHA256(filePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[MalwareDetector ERROR] Could not hash file %s: %v\n", filePath, err)
		return nil, false
	}

	// 2. Check threat intelligence (VirusTotal)
	if md.virusTotalAPIKey != "" {
		vtIndicators, vtFound := md.checkVirusTotal(fileHash, filePath)
		if vtFound {
			indicators = append(indicators, vtIndicators...)
			foundThreat = true
		}
	}

	// 3. ClamAV scan
	if md.clamavAvailable {
		clamIndicators, clamFound := md.scanWithClamAV(filePath)
		if clamFound {
			indicators = append(indicators, clamIndicators...)
			foundThreat = true
		}
	}

	// 4. YARA scan
	yaraIndicators, yaraFound := md.scanWithYARA(filePath, nil)
	if yaraFound {
		indicators = append(indicators, yaraIndicators...)
		foundThreat = true
	}

	// 5. Update recent indicators
	if len(indicators) > 0 {
		for _, ind := range indicators {
			md.addRecentIndicator(ind)
		}
	}

	return indicators, foundThreat
}

// checkVirusTotal queries VirusTotal API for file hash
func (md *MalwareDetector) checkVirusTotal(hash, filePath string) ([]ThreatIndicator, bool) {
	// Check cache first
	md.cacheMu.RLock()
	cached, exists := md.threatIntelCache[hash]
	md.cacheMu.RUnlock()

	if exists && time.Since(cached.LastCheck) < 24*time.Hour {
		if cached.Malicious {
			indicator := ThreatIndicator{
				Timestamp: time.Now(),
				SourceID:  "VIRUSTOTAL-CACHED",
				Target:    filePath,
				Severity:  ThreatLevelCritical,
				Signature: hash,
				Context:   fmt.Sprintf("Known malicious file (cached): %d/%d vendors detected", cached.Detections, len(cached.Vendors)),
				Action:    ActionQuarantineFile,
			}
			return []ThreatIndicator{indicator}, true
		}
		return nil, false
	}

	// Query VirusTotal API v3
	url := fmt.Sprintf("https://www.virustotal.com/api/v3/files/%s", hash)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, false
	}

	req.Header.Set("x-apikey", md.virusTotalAPIKey)

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("[MalwareDetector] VirusTotal API error: %v\n", err)
		return nil, false
	}
	defer resp.Body.Close()

	if resp.StatusCode == 404 {
		// File not found in VT database
		return nil, false
	}

	if resp.StatusCode != 200 {
		fmt.Printf("[MalwareDetector] VirusTotal API returned status %d\n", resp.StatusCode)
		return nil, false
	}

	var result struct {
		Data struct {
			Attributes struct {
				LastAnalysisStats struct {
					Malicious  int `json:"malicious"`
					Suspicious int `json:"suspicious"`
				} `json:"last_analysis_stats"`
				LastAnalysisResults map[string]struct {
					Category   string `json:"category"`
					EngineName string `json:"engine_name"`
				} `json:"last_analysis_results"`
			} `json:"attributes"`
		} `json:"data"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, false
	}

	detections := result.Data.Attributes.LastAnalysisStats.Malicious
	totalVendors := len(result.Data.Attributes.LastAnalysisResults)

	// Cache result
	cacheEntry := &ThreatIntelResult{
		Hash:       hash,
		Malicious:  detections > 0,
		Detections: detections,
		LastCheck:  time.Now(),
		Vendors:    make([]string, 0),
	}

	for _, analysis := range result.Data.Attributes.LastAnalysisResults {
		if analysis.Category == "malicious" {
			cacheEntry.Vendors = append(cacheEntry.Vendors, analysis.EngineName)
		}
	}

	md.cacheMu.Lock()
	md.threatIntelCache[hash] = cacheEntry
	md.cacheMu.Unlock()

	if detections > 0 {
		severity := ThreatLevelMedium
		if detections > 5 {
			severity = ThreatLevelHigh
		}
		if detections > 10 {
			severity = ThreatLevelCritical
		}

		indicator := ThreatIndicator{
			Timestamp: time.Now(),
			SourceID:  "VIRUSTOTAL",
			Target:    filePath,
			Severity:  severity,
			Signature: hash,
			Context:   fmt.Sprintf("VirusTotal detection: %d/%d vendors flagged as malicious", detections, totalVendors),
			Action:    ActionQuarantineFile,
			Details: map[string]interface{}{
				"hash":       hash,
				"detections": detections,
				"vendors":    cacheEntry.Vendors,
			},
		}
		return []ThreatIndicator{indicator}, true
	}

	return nil, false
}

// scanWithClamAV scans file using ClamAV daemon
func (md *MalwareDetector) scanWithClamAV(filePath string) ([]ThreatIndicator, bool) {
	if !md.clamavAvailable {
		return nil, false
	}

	conn, err := net.Dial("unix", md.clamavSocket)
	if err != nil {
		fmt.Printf("[MalwareDetector] Failed to connect to ClamAV: %v\n", err)
		md.clamavAvailable = false
		return nil, false
	}
	defer conn.Close()

	// Send SCAN command
	absPath, err := filepath.Abs(filePath)
	if err != nil {
		return nil, false
	}

	cmd := fmt.Sprintf("SCAN %s\n", absPath)
	if _, err := conn.Write([]byte(cmd)); err != nil {
		return nil, false
	}

	// Read response
	scanner := bufio.NewScanner(conn)
	if scanner.Scan() {
		response := scanner.Text()

		// Parse ClamAV response: "path: virusname FOUND" or "path: OK"
		if strings.Contains(response, "FOUND") {
			parts := strings.Split(response, ":")
			if len(parts) >= 2 {
				virusName := strings.TrimSpace(strings.Replace(parts[1], "FOUND", "", 1))

				indicator := ThreatIndicator{
					Timestamp: time.Now(),
					SourceID:  "CLAMAV",
					Target:    filePath,
					Severity:  ThreatLevelHigh,
					Signature: virusName,
					Context:   fmt.Sprintf("ClamAV detected: %s", virusName),
					Action:    ActionQuarantineFile,
				}
				return []ThreatIndicator{indicator}, true
			}
		}
	}

	return nil, false
}

// ScanData performs in-memory scanning
func (md *MalwareDetector) ScanData(data []byte, target string, sourceIP string, protocol string) ([]ThreatIndicator, bool) {
	indicators := make([]ThreatIndicator, 0)
	foundThreat := false // Variable declared

	// 1. Regex pattern matching
	for _, pattern := range md.regexPatterns {
		re, err := regexp.Compile(pattern.Pattern)
		if err != nil {
			continue
		}

		if re.Match(data) {
			indicators = append(indicators, ThreatIndicator{
				Timestamp: time.Now(),
				SourceID:  "REGEX-MATCH",
				SourceIP:  sourceIP,
				Target:    target,
				Protocol:  protocol,
				Severity:  pattern.Severity,
				Signature: pattern.Name,
				Context:   fmt.Sprintf("Regex pattern '%s' matched in data payload", pattern.Name),
				Action:    ActionNotify,
			})
			foundThreat = true // Variable assigned (written to)
		}
	}

	// 2. YARA rule matching
	yaraIndicators, yaraFound := md.scanWithYARA(target, data)
	if yaraFound {
		indicators = append(indicators, yaraIndicators...)
		foundThreat = true
	}

	// *** The Fix is Here: Return the values ***
	return indicators, foundThreat // Variable read from (used)
}

// scanWithYARA performs YARA scanning
func (md *MalwareDetector) scanWithYARA(target string, data []byte) ([]ThreatIndicator, bool) {
	if md.yaraRulesCompiled == nil {
		return nil, false
	}

	indicators := make([]ThreatIndicator, 0)

	var matches yara.MatchRules
	var err error

	if data == nil {
		// Scan file
		err = md.yaraRulesCompiled.ScanFile(target, yara.ScanFlags(0), 30*time.Second, &matches)
		if err != nil {
			return nil, false
		}
	} else {
		// Scan memory
		err = md.yaraRulesCompiled.ScanMem(data, yara.ScanFlags(0), 30*time.Second, &matches)
		if err != nil {
			return nil, false
		}
	}

	if err != nil {
		fmt.Fprintf(os.Stderr, "[MalwareDetector ERROR] YARA scan failed on %s: %v\n", target, err)
		return nil, false
	}

	sourceIP := ""
	protocol := ""
	if data != nil && target != "" {
		parts := strings.Split(target, ":")
		if len(parts) >= 2 {
			sourceIP = parts[0]
			protocol = parts[1]
		}
	}

	if len(matches) > 0 {
		for _, match := range matches {
			matchedStrings := make([]string, 0)
			for _, str := range match.Strings {
				matchedStrings = append(matchedStrings, fmt.Sprintf("%s at offset %d", str.Name, str.Offset))
			}

			indicators = append(indicators, ThreatIndicator{
				Timestamp: time.Now(),
				SourceID:  "YARA-MATCH",
				SourceIP:  sourceIP,
				Target:    target,
				Protocol:  protocol,
				Severity:  ThreatLevelHigh,
				Signature: match.Rule,
				Context:   fmt.Sprintf("YARA rule '%s' matched in target", match.Rule),
				Details: map[string]interface{}{
					"description":     fmt.Sprintf("YARA rule '%s' matched", match.Rule),
					"namespace":       match.Namespace,
					"matched_strings": matchedStrings,
					"tags":            match.Tags,
				},
				Action: ActionQuarantineFile,
			})
		}
	}

	if len(indicators) > 0 {
		for _, ind := range indicators {
			md.addRecentIndicator(ind)
		}
		return indicators, true
	}

	return nil, false
}

// addRecentIndicator adds indicator to rolling list
func (md *MalwareDetector) addRecentIndicator(ind ThreatIndicator) {
	md.mu.Lock()
	defer md.mu.Unlock()

	if len(md.recentIndicators) >= MaxRecentIndicators {
		md.recentIndicators = md.recentIndicators[1:]
	}
	md.recentIndicators = append(md.recentIndicators, ind)
}

// GetRecentIndicators returns copy of recent indicators
func (md *MalwareDetector) GetRecentIndicators() []ThreatIndicator {
	md.mu.Lock()
	defer md.mu.Unlock()

	indicators := make([]ThreatIndicator, len(md.recentIndicators))
	copy(indicators, md.recentIndicators)
	return indicators
}

// UpdateDefinitions updates malware definitions from remote sources
func (md *MalwareDetector) UpdateDefinitions() (string, error) {
	md.mu.Lock()
	defer md.mu.Unlock()

	fmt.Println("[MalwareDetector] Updating malware definitions...")

	// Update YARA rules if file exists
	if md.yaraRulesCompiled != nil {
		// Simulate rule update
		fmt.Println("[MalwareDetector] YARA rules updated (simulated)")
	}

	// Update ClamAV signatures
	if md.clamavAvailable {
		// In a real implementation, this would trigger freshclam
		fmt.Println("[MalwareDetector] ClamAV signatures updated (simulated)")
	}

	// Clear old cache entries
	md.cacheMu.Lock()
	for hash, entry := range md.threatIntelCache {
		if time.Since(entry.LastCheck) > 7*24*time.Hour {
			delete(md.threatIntelCache, hash)
		}
	}
	md.cacheMu.Unlock()

	return "Malware definitions updated successfully", nil
}
