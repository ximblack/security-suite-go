package main

import (
	"fmt"
	"strconv"
	"sync"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
)

// NetworkMalwareScanner performs real-time packet capture and analysis
type NetworkMalwareScanner struct {
	Interface          string
	MalwareDetector    *MalwareDetector
	BehavioralAnalyzer *BehavioralAnalyzer
	Orchestrator       *ResponseOrchestrator
	StopChan           chan struct{}
	IsRunning          bool
	mu                 sync.Mutex
	PacketCount        int64
	handle             *pcap.Handle
	flowTracker        map[string]*FlowStats
	flowMu             sync.RWMutex
}

// FlowStats tracks statistics for a network flow
type FlowStats struct {
	SourceIP    string
	DestIP      string
	SourcePort  uint16
	DestPort    uint16
	Protocol    string
	PacketCount int64
	BytesIn     int64
	BytesOut    int64
	FirstSeen   time.Time
	LastSeen    time.Time
	DNSQueries  int
	Connections int
}

// NewNetworkMalwareScanner initializes the scanner
func NewNetworkMalwareScanner(iface string, md *MalwareDetector, ba *BehavioralAnalyzer, ro *ResponseOrchestrator) *NetworkMalwareScanner {
	return &NetworkMalwareScanner{
		Interface:          iface,
		MalwareDetector:    md,
		BehavioralAnalyzer: ba,
		Orchestrator:       ro,
		StopChan:           make(chan struct{}),
		IsRunning:          false,
		PacketCount:        0,
		flowTracker:        make(map[string]*FlowStats),
	}
}

// StartScan initiates real packet capture using libpcap
func (nms *NetworkMalwareScanner) StartScan() error {
	nms.mu.Lock()
	if nms.IsRunning {
		nms.mu.Unlock()
		return fmt.Errorf("scanner is already running on interface %s", nms.Interface)
	}
	nms.IsRunning = true
	nms.mu.Unlock()

	// Open device for packet capture
	handle, err := pcap.OpenLive(nms.Interface, 1600, true, pcap.BlockForever)
	if err != nil {
		nms.mu.Lock()
		nms.IsRunning = false
		nms.mu.Unlock()
		return fmt.Errorf("failed to open device %s: %v", nms.Interface, err)
	}
	nms.handle = handle

	fmt.Printf("[NetworkMalwareScanner] Started packet capture on %s\n", nms.Interface)

	// Start packet processing goroutine
	go nms.captureLoop()

	// Start periodic analysis goroutine
	go nms.periodicAnalysis()

	return nil
}

// captureLoop continuously captures and processes packets
func (nms *NetworkMalwareScanner) captureLoop() {
	defer nms.handle.Close()

	packetSource := gopacket.NewPacketSource(nms.handle, nms.handle.LinkType())

	for {
		select {
		case <-nms.StopChan:
			fmt.Println("[NetworkMalwareScanner] Stopping packet capture...")
			return

		case packet := <-packetSource.Packets():
			if packet == nil {
				continue
			}
			nms.PacketCount++
			nms.processPacket(packet)
		}
	}
}

// processPacket analyzes individual packets
func (nms *NetworkMalwareScanner) processPacket(packet gopacket.Packet) {
	// Extract network layer
	networkLayer := packet.NetworkLayer()
	if networkLayer == nil {
		return
	}

	var srcIP, dstIP string
	var protocol string

	// Parse IP layer
	if ipv4Layer := packet.Layer(layers.LayerTypeIPv4); ipv4Layer != nil {
		ipv4, _ := ipv4Layer.(*layers.IPv4)
		srcIP = ipv4.SrcIP.String()
		dstIP = ipv4.DstIP.String()
		protocol = ipv4.Protocol.String()
	} else if ipv6Layer := packet.Layer(layers.LayerTypeIPv6); ipv6Layer != nil {
		ipv6, _ := ipv6Layer.(*layers.IPv6)
		srcIP = ipv6.SrcIP.String()
		dstIP = ipv6.DstIP.String()
		protocol = ipv6.NextHeader.String()
	} else {
		return
	}

	// Parse transport layer
	var srcPort, dstPort uint16
	var payload []byte

	if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil {
		tcp, _ := tcpLayer.(*layers.TCP)
		srcPort = uint16(tcp.SrcPort)
		dstPort = uint16(tcp.DstPort)
		payload = tcp.Payload
		protocol = "TCP"
	} else if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil {
		udp, _ := udpLayer.(*layers.UDP)
		srcPort = uint16(udp.SrcPort)
		dstPort = uint16(udp.DstPort)
		payload = udp.Payload
		protocol = "UDP"
	}

	// Track flow statistics
	flowKey := fmt.Sprintf("%s:%s->%s:%s", srcIP, strconv.Itoa(int(srcPort)), dstIP, strconv.Itoa(int(dstPort)))
	nms.updateFlowStats(flowKey, srcIP, dstIP, srcPort, dstPort, protocol, len(packet.Data()))

	// Check for DNS queries
	if dstPort == 53 && len(payload) > 0 {
		nms.incrementDNSCount(srcIP)
	}

	// Signature-based detection on payload
	if len(payload) > 0 {
		targetID := fmt.Sprintf("%s:%s", srcIP, protocol)
		indicators, found := nms.MalwareDetector.ScanData(payload, targetID, srcIP, protocol)
		if found {
			for _, indicator := range indicators {
				fmt.Printf("[ALERT] Malware signature detected: %s from %s\n", indicator.Signature, srcIP)
				// Forward to orchestrator for response
				go nms.Orchestrator.HandleThreat(indicator)
			}
		}
	}
}

// updateFlowStats updates statistics for a network flow
func (nms *NetworkMalwareScanner) updateFlowStats(flowKey, srcIP, dstIP string, srcPort, dstPort uint16, protocol string, packetSize int) {
	nms.flowMu.Lock()
	defer nms.flowMu.Unlock()

	flow, exists := nms.flowTracker[flowKey]
	if !exists {
		flow = &FlowStats{
			SourceIP:    srcIP,
			DestIP:      dstIP,
			SourcePort:  srcPort,
			DestPort:    dstPort,
			Protocol:    protocol,
			FirstSeen:   time.Now(),
			Connections: 1,
		}
		nms.flowTracker[flowKey] = flow
	}

	flow.PacketCount++
	flow.BytesOut += int64(packetSize)
	flow.LastSeen = time.Now()

	// Track reverse flow for bytes in
	reverseKey := fmt.Sprintf("%s:%s->%s:%s", dstIP, strconv.Itoa(int(dstPort)), srcIP, strconv.Itoa(int(srcPort)))
	if reverseFlow, exists := nms.flowTracker[reverseKey]; exists {
		flow.BytesIn = reverseFlow.BytesOut
	}
}

// incrementDNSCount increments DNS query count for an IP
func (nms *NetworkMalwareScanner) incrementDNSCount(srcIP string) {
	nms.flowMu.Lock()
	defer nms.flowMu.Unlock()

	// Find flows from this source and increment DNS counter
	for _, flow := range nms.flowTracker {
		if flow.SourceIP == srcIP {
			flow.DNSQueries++
			break
		}
	}
}

// periodicAnalysis performs behavioral analysis periodically
func (nms *NetworkMalwareScanner) periodicAnalysis() {
	ticker := time.NewTicker(30 * time.Second) // Analyze every 30 seconds
	defer ticker.Stop()

	for {
		select {
		case <-nms.StopChan:
			return

		case <-ticker.C:
			nms.analyzeFlows()
		}
	}
}

// analyzeFlows performs behavioral analysis on tracked flows
func (nms *NetworkMalwareScanner) analyzeFlows() {
	nms.flowMu.RLock()
	flowsCopy := make(map[string]*FlowStats)
	for k, v := range nms.flowTracker {
		flowsCopy[k] = v
	}
	nms.flowMu.RUnlock()

	// Aggregate statistics per source IP
	ipStats := make(map[string]*IPStatistics)

	for _, flow := range flowsCopy {
		stats, exists := ipStats[flow.SourceIP]
		if !exists {
			stats = &IPStatistics{
				IP:          flow.SourceIP,
				TotalBytes:  0,
				Connections: 0,
				DNSQueries:  0,
			}
			ipStats[flow.SourceIP] = stats
		}

		stats.TotalBytes += flow.BytesOut + flow.BytesIn
		stats.Connections += flow.Connections
		stats.DNSQueries += flow.DNSQueries
		stats.UniqueDestinations++
	}

	// Update behavioral profiles and check for anomalies
	for ip, stats := range ipStats {
		// Create feature vector: [bytes_in, bytes_out, conn_rate, dns_count]
		duration := 30.0 // 30 seconds
		connRate := float64(stats.Connections) / duration

		featureVector := []float64{
			float64(stats.TotalBytes / 2), // Approximate bytes in
			float64(stats.TotalBytes / 2), // Approximate bytes out
			connRate,
			float64(stats.DNSQueries),
		}

		// Update behavioral profile
		profile := nms.BehavioralAnalyzer.UpdateProfile(ip, featureVector, true)

		// Analyze for anomalies
		indicators, _ := nms.BehavioralAnalyzer.AnalyzeProfile(ip)
		if len(indicators) > 0 {
			for _, indicator := range indicators {
				fmt.Printf("[ALERT] Behavioral anomaly: %s from %s\n", indicator.Context, ip)
				// Forward to orchestrator
				go nms.Orchestrator.HandleThreat(indicator)
			}
		}

		// Log profile update
		if profile != nil {
			fmt.Printf("[NetworkMonitor] Updated profile for %s: %.0f bytes, %.2f conn/s, %d DNS queries\n",
				ip, float64(stats.TotalBytes), connRate, stats.DNSQueries)
		}
	}

	// Cleanup old flows (older than 5 minutes)
	nms.cleanupOldFlows()
}

// IPStatistics aggregates statistics per IP
type IPStatistics struct {
	IP                 string
	TotalBytes         int64
	Connections        int
	DNSQueries         int
	UniqueDestinations int
}

// cleanupOldFlows removes flows older than 5 minutes
func (nms *NetworkMalwareScanner) cleanupOldFlows() {
	nms.flowMu.Lock()
	defer nms.flowMu.Unlock()

	cutoff := time.Now().Add(-5 * time.Minute)
	for key, flow := range nms.flowTracker {
		if flow.LastSeen.Before(cutoff) {
			delete(nms.flowTracker, key)
		}
	}
}

// StopScan stops packet capture gracefully
func (nms *NetworkMalwareScanner) StopScan() bool {
	nms.mu.Lock()
	defer nms.mu.Unlock()

	if !nms.IsRunning {
		return true
	}

	close(nms.StopChan)
	nms.IsRunning = false

	// Reinitialize stop channel for next start
	nms.StopChan = make(chan struct{})

	fmt.Println("[NetworkMalwareScanner] Packet capture stopped")
	return true
}

// GetStatus reports scanner status
func (nms *NetworkMalwareScanner) GetStatus() bool {
	nms.mu.Lock()
	defer nms.mu.Unlock()
	return nms.IsRunning
}

// GetStatistics returns current capture statistics
func (nms *NetworkMalwareScanner) GetStatistics() map[string]interface{} {
	nms.flowMu.RLock()
	defer nms.flowMu.RUnlock()

	return map[string]interface{}{
		"packets_captured": nms.PacketCount,
		"active_flows":     len(nms.flowTracker),
		"interface":        nms.Interface,
		"is_running":       nms.IsRunning,
	}
}
